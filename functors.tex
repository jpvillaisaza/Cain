\chapter{Functors}
\label{chap:functors}

\epigraph{
  \emph{Category} has been defined in order to be able to
  define \emph{functor}...
}{---\textcite[18]{maclane-1998}}

In this chapter we explore functors. In Section \ref{sec:functors} we
define mathematical functors, and in Sections
\ref{sec:functors-haskell} and \ref{sec:functors-agda} we describe
functors in Haskell and Agda, respectively.

\section{Introduction}
\label{sec:functors-introduction}

Mapping over lists, which is accomplished with the \texthaskell{map}
function, is ``a dominant idiom in Haskell''
\parencite[146]{lipovaca-2011}. The type signature of the
\texthaskell{map} function is:
\begin{codehaskell}
map :: (a -> b) -> [a] -> [b]
\end{codehaskell}
According to the documentation of the Haskell Prelude, given a
function \texthaskell{f} and a list \texthaskell{xs}, \texthaskell{map
  f xs} is the list obtained by applying \texthaskell{f} to each
element in \texthaskell{xs}. In other words:
\begin{codehaskell}
map f [x1, x2, ..., xn] = [f x1, f x2, ..., f xn]
\end{codehaskell}
Or, better:
\begin{codehaskell}
map f [x1, x2, ...] = [f x1, f x2, ...]
\end{codehaskell}
The definition of the \texthaskell{map} function is:
\begin{codehaskell}
map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs
\end{codehaskell}

Even though this is the correct definition of the \texthaskell{map}
function (it applies a function to all the elements of a list), it is
possible to implement alternative definitions. For instance:
\begin{codehaskell}
map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : f x : map f xs
\end{codehaskell}
This alternative \texthaskell{map} function applies a function to each
element in a list and duplicates each result.

Deciding whether the former or the latter \texthaskell{map} function
is the correct one for mapping over lists requires a more general
approach. This is achieved with the definition of the
\texthaskell{Functor} type class, which is used for types that can be
mapped over and which generalizes the \texthaskell{map} function as a
\emph{uniform} action over a parameterized type such as
\texthaskell{[a]} in \texthaskell{(a -> b) -> [a] -> [b]}.

However, the definition of the \texthaskell{Functor} type class is not
enough to determine what a ``uniform action over a parameterized
type'' is. On the other hand, a comment in Haskell's documentation
states that all instances of the \texthaskell{Functor} type class
\emph{should} satisfy the functor laws. These laws, which are not part
of the definition of functors in Haskell, guarantee that a ``uniform
action over a parameterized type'' is actually uniform.

Functors in Haskell implement mathematical functors (that is, functors
in category theory) and the functor laws correspond to the conditions
that a mathematical functor \emph{must} satisfy in order to be a
functor. Studying mathematical functors may not be necessary for
uniformly mapping over a parameterized type, but it may be very useful
for better understanding what that means.

\section{Functors}
\label{sec:functors}

The concepts of functor and endofunctor are fundamental to our
development. In detail:

\begin{definition}
  \label{def:functor}

  %% \parencites[13]{maclane-1998}[428]{poigne-1992}

  Let \cat{C} and \cat{D} be categories\footnote{Whenever a category
    \cat{C} is mentioned, its sets of objects and morphisms, its
    domain and codomain functions, and its identity and composition
    functions (\catO{C} and \catM{C}, $\dom$ and $\cod$, and $\id$ and
    $\comp$, respectively) are implicitly mentioned as well. See
    Definition \ref{def:category}.}. A functor $\func{F}: \cat{C} \to
  \cat{D}$ consists of an object function
  %% Let $\cat{C}$ and $\cat{D}$ be categories. A functor $\func{F}:
  %% \cat{C} \to \cat{D}$ assigns to each object $a$ of $\cat{C}$ an
  %% object $\funcO{F}(a)$ of $\cat{D}$, and to each morphism $f: a \to
  %% b$ of $\cat{C}$ a morphism
  %% $\funcM{F}(f): \funcO{F}(a) \to \funcO{F}(b) \in \catM{D}$ such that,
  \begin{equation}
    \label{eq:functor-object}
    \funcO{F}: \catO{C} \to \catO{D}
  \end{equation}
  and a morphism function
  \begin{equation}
    \label{eq:functor-morphism}
    \funcM{F}: \catM{C} \to \catM{D}
    \text{,}
  \end{equation}
  which assigns to each morphism $f: a \to b \in \catM{C}$ a morphism
  \begin{equation*}
    \funcM{F}(f): \funcO{F}(a) \to \funcO{F}(b) \in \catM{D}
    \text{,}
  \end{equation*}
  such that, for all objects $a$ in \cat{C},
  \begin{equation}
    \label{eq:functor-identity}
    \funcM{F}(\idO{a}) = \idO{\funcO{F}(a)}
    \text{,}
  \end{equation}
  and, for all morphisms $f: a \to b$ and $g: b \to c$ in \cat{C},
  \begin{equation}
    \label{eq:functor-composition}
    \funcM{F}(g \comp f) = \funcM{F}(g) \comp \funcM{F}(f)
    \text{.}
  \end{equation}

\end{definition}

\begin{definition}
  \label{def:endofunctor}

  An endofunctor is a functor from a category to itself.

\end{definition}

\begin{example}
  \label{ex:functor-power-set}

  %% \parencites[13]{maclane-1998}[10--11]{marquis-2013}[431]{poigne-1992}

  The power set operation yields a functor $\func{P}: \set \to \set$.
  Its object function $\funcO{P}$ is the power set operation, that is,
  given a set $A$, $\funcO{P}(A)$ is the set of all subsets of $A$:
  \begin{equation}
    \label{eq:functor-power-set-object}
    \funcO{P}(A) = \{X \mid X \subseteq A\}
    \text{.}
  \end{equation}
  And its morphism function $\funcM{P}$ assigns to each function $f: A
  \to B$ a function $\funcM{P}(f): \funcO{P}(A) \to \funcO{P}(B)$ such
  that
  \begin{equation}
    \label{eq:functor-power-set-morphism}
    \funcM{P}(f)(X) = \{f(x) \mid x \in X\}
  \end{equation}
  for all $X \in \funcO{P}(A)$.

  \begin{proof}

    We need to prove that \eqref{eq:functor-identity} and
    \eqref{eq:functor-composition} hold. In the first place:
    \begin{steps}
      \step{$\funcM{P}(\idO{A})(X)$}
        \eqby{\eqref{eq:functor-power-set-morphism} with $f = \idO{A}$}
      \step{$\{\idO{A}(x) \mid x \in X\}$}
        \eqby{\eqref{eq:set-identity}}
      \step{$\{x \mid x \in X\}$}
        \eqbynothing
      \step{$X$}
        \eqby{\eqref{eq:set-identity} with $A = \funcO{P}(A)$ and $x = X$}
      \step{$\idO{\funcO{P}(A)}(X)$}
    \end{steps}
    And, in the second place:
    \begin{steps}
      \step{$\funcM{P}(g \comp f)(X)$}
        \eqby{\eqref{eq:functor-power-set-morphism} with $f = g \comp f$}
      \step{$\{(g \comp f)(x) \mid x \in X\}$}
        \eqby{\eqref{eq:set-composition}}
      \step{$\{g(f(x)) \mid x \in X\}$}
        \eqby{\eqref{eq:functor-power-set-morphism} with $f = g$ and $X = \{f(x) \mid x \in X\}$}
      \step{$\funcM{P}(g)(\{f(x) \mid x \in X\})$}
        \eqby{\eqref{eq:functor-power-set-morphism}}
      \step{$\funcM{P}(g)(\funcM{P}(f)(X))$}
        \eqby{\eqref{eq:set-composition} with $f = \funcM{P}(f)$, $g = \funcM{P}(g)$, and $x = X$}
      \step{$(\funcM{P}(g) \comp \funcM{P}(f))(X)$}
    \end{steps}

  \end{proof}

\end{example}

\begin{example}
  \label{ex:functor-identity}

  %% \parencite[11]{marquis-2013}

  Given a category \cat{C}, its identity functor $\func{I}: \cat{C}
  \to \cat{C}$ sends all objects and morphisms of \cat{C} to
  themselves. In detail, the object function $\funcO{I}: \catO{C} \to
  \catO{C}$ is defined as
  \begin{equation}
    \label{eq:functor-identity-object}
    \funcO{I}(a) = a
  \end{equation}
  for all $a \in \catO{C}$, and the morphism function $\funcM{I}:
  \catM{C} \to \catM{C}$ as
  \begin{equation}
    \label{eq:functor-identity-morphism}
    \funcM{I}(f) = f
  \end{equation}
  for all $f \in \catM{C}$.

  \begin{proof}

    We verify that \eqref{eq:functor-identity} and
    \eqref{eq:functor-composition} hold:
    \begin{steps}
      \step{$\funcM{I}(\idO{a})$}
        \eqby{\eqref{eq:functor-identity-morphism} with $f = \idO{a}$}
      \step{$\idO{a}$}
        \eqby{\eqref{eq:functor-identity-object}}
      \step{$\idO{\funcO{I}(a)}$}
    \end{steps}
    And:
    \begin{steps}
      \step{$\funcM{I}(g \comp f)$}
        \eqby{\eqref{eq:functor-identity-morphism} with $f = g \comp f$}
      \step{$g \comp f$}
        \eqby{\eqref{eq:functor-identity-morphism} with $f = g$ and \eqref{eq:functor-identity-morphism}}
      \step{$\funcM{I}(g) \comp \funcM{I}(f)$}
    \end{steps}

  \end{proof}

\end{example}

\section{Functors in Haskell}
\label{sec:functors-haskell}

Functors in Haskell are defined by ``the most basic and ubiquitous
type class in the Haskell libraries'' \parencite[18]{yorgey-2009}, the
\texthaskell{Functor} type class, which is exported by the Haskell
Prelude:
\begin{codehaskell}
class Functor f where
  fmap :: (a -> b) -> f a -> f b
\end{codehaskell}
It is used for types that can be mapped over, and generalizes the
\texthaskell{map} function on lists with a uniform action over a
parameterized type. Intuitively, functors represent containers or
computational contexts, but we are more interested in their definition
and its relation to that of mathematical functors.

It is important to note that \texthaskell{f} is a type constructor
rather than a type (its kind is \texthaskell{* -> *} and not
\texthaskell{*}). \texthaskell{[]} and \texthaskell{Maybe} are
examples of such type constructors. The result of applying a type
constructor to a type (for example, \texthaskell{Int} or
\texthaskell{Bool}) is a type or concrete type (that is, something of
kind \texthaskell{*}). Therefore, the kinds of \texthaskell{[] Int}
(that is, \texthaskell{[Int]}) and \texthaskell{Maybe Int} are both
\texthaskell{*}. As another example, since the kind of
\texthaskell{Either} is \texthaskell{* -> * -> *}, it can not be
declared as an instance of the \texthaskell{Functor} type class.
However, a type constructor can be partially applied and something
like \texthaskell{Either a} can be declared as an instance of
\texthaskell{Functor}.

The fact that \texthaskell{f} is a type constructor can be made
explicit using the language option \texthaskell{KindSignatures}:
\begin{codehaskell}
class Functor (f :: * -> *) where
  fmap :: (a -> b) -> f a -> f b
\end{codehaskell}
The kind signature of \texthaskell{f} shows that it corresponds to the
object function of a mathematical functor (that is,
\eqref{eq:functor-object}): it sends objects of \hask (types) to
objects of \hask (types).

Also, \texthaskell{fmap} is curried and can be rewritten with extra
and unnecessary parentheses for emphasis:
\begin{codehaskell}
class Functor (f :: * -> *) where
  fmap :: (a -> b) -> (f a -> f b)
\end{codehaskell}
The type of \texthaskell{fmap} shows that it corresponds to the
morphism function of a mathematical functor (that is,
\eqref{eq:functor-morphism}): it sends morphisms of \hask (functions)
to morphisms of \hask (functions).

In summary, instances of the \texthaskell{Functor} type class
correspond to functors (more precisely, endofunctors) from \hask to
\hask with the type constructor and the \texthaskell{fmap} function as
the required object and morphism functions.

Although Haskell's documentation states that functors \emph{should}
obey the functor laws, this is not mandatory when declaring an
instance of the \texthaskell{Functor} type class. The first law can be
stated as:
\begin{codehaskell}
fmap id = id
\end{codehaskell}
Polymorphism in Haskell allows us to write just \texthaskell{id} in
both sides of this law, but the types of each \texthaskell{id} are
different (which is more obvious when comparing this with
\eqref{eq:functor-identity}). A more precise way of stating the first
law in Haskell follows:
\begin{codehaskell}
fmap (id :: a -> a) = (id :: f a -> f a)
\end{codehaskell}
And the second law can be stated as:
\begin{codehaskell}
fmap (g . f) = fmap g . fmap f
\end{codehaskell}
This law corresponds to \eqref{eq:functor-composition}. Proving both
of these laws amounts to proving that an instance of the
\texthaskell{Functor} type class is actually a functor.

\begin{remark}

  A different approach is that of \parencite{jeuring-2012}, which
  includes the implementation of a library for testing the laws of
  type classes such as \texthaskell{Functor}.

\end{remark}

\begin{example}
  \label{ex:functor-identity-haskell}

  The identity functor of \hask, which is just an instance of the
  identity functor as described in Example \ref{ex:functor-identity},
  is defined as follows:
  \begin{codehaskell}
newtype Identity a = Identity {unIdentity :: a}

instance Functor Identity where
  fmap f (Identity x) = Identity (f x)
  \end{codehaskell}

  %% Note that \texthaskell{Identity a} is a renamed data type which is
  %% isomorphic to \texthaskell{a}. See \parencite[§
  %%   4.2.3]{peytonjones-2003}.

  \begin{proof}

    See the proof of Example \ref{ex:functor-identity}.

  \end{proof}

\end{example}

\begin{example}
  \label{ex:functor-maybe-haskell}

  %% \parencites[147--148]{lipovaca-2011}[246]{osullivan-2008}[20--21]{yorgey-2009}

  A common example of functors in Haskell is the \texthaskell{Maybe}
  functor. Its type constructor is, of course, the \texthaskell{Maybe}
  type constructor:
  \begin{codehaskell}
data Maybe a = Nothing | Just a
  \end{codehaskell}
  And its \texthaskell{fmap} function is defined as follows:
  \begin{codehaskell}
instance Functor Maybe where
  fmap _ Nothing  = Nothing
  fmap f (Just x) = Just (f x)
  \end{codehaskell}
  Basically, the \texthaskell{Maybe} type constructor sends types
  \texthaskell{a} to types \texthaskell{Maybe a}, a value of type
  \texthaskell{Maybe a} either contains a value of type
  \texthaskell{a} or is empty, and the \texthaskell{fmap} function
  sends functions \texthaskell{a -> b} to functions \texthaskell{Maybe
    a -> Maybe b}.

  \begin{proof}

    First, we prove that \eqref{eq:functor-identity} holds. In the
    case of \texthaskell{Nothing}:
    \begin{steps}
      \steph{fmap id Nothing}
        \eqbydefh{fmap}
      \steph{Nothing}
        \eqbydefh{id}
      \steph{id Nothing}
    \end{steps}
    And in the case of \texthaskell{Just x}:
    \begin{steps}
      \steph{fmap id (Just x)}
        \eqbydefh{fmap}
      \steph{Just (id x)}
        \eqbydefh{id}
      \steph{Just x}
        \eqbydefh{id}
      \steph{id (Just x)}
    \end{steps}
    And, second, we prove that \eqref{eq:functor-composition} holds.
    In the case of \texthaskell{Nothing}:
    \begin{steps}
      \steph{(fmap g . fmap f) Nothing}
        \eqbydefh{(.)}
      \steph{fmap g (fmap f Nothing)}
        \eqbydefh{fmap}
      \steph{fmap g Nothing}
        \eqbydefh{fmap}
      \steph{Nothing}
        \eqbydefh{fmap}
      \steph{fmap (g . f) Nothing}
    \end{steps}
    And in the case of \texthaskell{Just x}:
    \begin{steps}
      \steph{fmap (g . f) (Just x)}
        \eqbydefh{fmap}
      \steph{Just ((g . f) x)}
        \eqbydefh{(.)}
      \steph{Just (g (f x))}
        \eqbydefh{fmap}
      \steph{fmap g (Just (f x))}
        \eqbydefh{fmap}
      \steph{fmap g (fmap f (Just x))}
        \eqbydefh{(.)}
      \steph{(fmap g . fmap f) (Just x)}
    \end{steps}

  \end{proof}

\end{example}

\begin{example}
  \label{ex:functor-list-haskell}

  %% \parencites[146--147]{lipovaca-2011}[20--21]{yorgey-2009}

  Another common example of functors in Haskell is the list functor.
  Its type constructor is \texthaskell{[]}, and its \texthaskell{fmap}
  function is, obviously, the \texthaskell{map} function:
  \begin{codehaskell}
instance Functor [] where
  fmap _ []     = []
  fmap f (x:xs) = f x : fmap f xs
  \end{codehaskell}
  Or:
  \begin{codehaskell}
instance Functor [] where
  fmap = map
  \end{codehaskell}
  The \texthaskell{[]} type constructor sends types \texthaskell{a} to
  types \texthaskell{[a]}, that is, lists of \texthaskell{a}, and the
  \texthaskell{fmap} or \texthaskell{map} function, which we talked
  about in Section \ref{sec:functors-introduction}, sends functions of
  type \texthaskell{a -> b} to functions of type \texthaskell{[a] ->
    [b]}.

  \begin{proof}

    First, we prove \eqref{eq:functor-identity} by induction. In the
    case of an empty list:
    \begin{steps}
      \steph{fmap id []}
        \eqbydefh{fmap}
      \steph{[]}
        \eqbydefh{id}
      \steph{id []}
    \end{steps}
    And in the case of a nonempty list \texthaskell{(x:xs)}:
    \begin{steps}
      \steph{fmap id (x:xs)}
        \eqbydefh{fmap}
      \steph{id x : fmap id xs}
        \eqbydefh{id}
      \steph{x : fmap id xs}
        \eqbyihh{}
      \steph{x:xs}
        \eqbydefh{id}
      \steph{id (x:xs)}
    \end{steps}
    And, second, we prove \eqref{eq:functor-composition}, also by
    induction. In the case of an empty list:
    \begin{steps}
      \steph{(fmap g . fmap f) []}
        \eqbydefh{(.)}
      \steph{fmap g (fmap f [])}
        \eqbydefh{fmap}
      \steph{fmap g []}
        \eqbydefh{fmap}
      \steph{[]}
        \eqbydefh{fmap}
      \steph{fmap (g . f) []}
    \end{steps}
    And in the case of a nonempty list \texthaskell{(x:xs)}:
    \begin{steps}
      \steph{fmap (g . f) (x:xs)}
        \eqbydefh{fmap}
      \steph{(g . f) x : fmap (g . f) xs}
        \eqbydefh{(.)}
      \steph{g (f x) : fmap (g . f) xs}
        \eqbyihh{}
      \steph{g (f x) : (fmap g . fmap f) xs}
        \eqbydefh{(.)}
      \steph{g (f x) : fmap g (fmap f xs)}
        \eqbydefh{fmap}
      \steph{fmap g (f x : fmap f xs)}
        \eqbydefh{fmap}
      \steph{fmap g (fmap f (x:xs))}
        \eqbydefh{(.)}
      \steph{(fmap g . fmap f) (x:xs)}
    \end{steps}

  \end{proof}

\end{example}

\begin{example}
  \label{ex:functor-product-haskell}

  %% \parencites[21]{yorgey-2009}

  Another usual example of functors in Haskell is the product functor.
  Its type constructor is \texthaskell{(,) a} (see Example
  \ref{ex:product-haskell}), and its \texthaskell{fmap} function is
  uniquely defined as follows:
  \begin{codehaskell}
instance Functor ((,) a) where
  fmap f (x, y) = (x, f y)
  \end{codehaskell}

  %% \texthaskell{((,) a)} represents a container which holds an
  %% annotation of type \texthaskell{a} along with the actual value it
  %% holds \parencite{yorgey-2009}. The first element of a tuple is never
  %% modified by \texthaskell{fmap}, it is fixed. Annotation?

  \begin{proof}

    We prove that \eqref{eq:functor-identity} and
    \eqref{eq:functor-composition} hold. In the first place:
    \begin{steps}
      \steph{fmap id (x, y)}
        \eqbydefh{fmap}
      \steph{(x, id y)}
        \eqbydefh{id}
      \steph{(x, y)}
        \eqbydefh{id}
      \steph{id (x, y)}
    \end{steps}
    And, in the second place:
    \begin{steps}
      \steph{(fmap h . fmap g) (x, y)}
        \eqbydefh{(.)}
      \steph{fmap h (fmap g (x, y))}
        \eqbydefh{fmap}
      \steph{fmap h (x, g y)}
        \eqbydefh{fmap}
      \steph{(x, h (g y))}
        \eqbydefh{(.)}
      \steph{(x, (h . g) y)}
        \eqbydefh{fmap}
      \steph{fmap (h . g) (x, y)}
    \end{steps}

  \end{proof}

\end{example}

\begin{example}
  \label{ex:functor-coproduct-haskell}

  %% \parencites[149]{lipovaca-2011}[21]{yorgey-2009}

  In a similar way, the coproduct functor is an usual example of
  functors in Haskell. Its type constructor is \texthaskell{Either a}
  (see Example \ref{ex:functor-coproduct-haskell}), and its
  \texthaskell{fmap} function is uniquely defined as follows:
  \begin{codehaskell}
instance Functor (Either a) where
  fmap _ (Left x)  = Left x
  fmap g (Right y) = Right (g y)
  \end{codehaskell}

  %% \texthaskell{Either a b} represents a container which can have
  %% either a value of type \texthaskell{a} (which usually represents
  %% some sort of error condition) or a value of type \texthaskell{b}. It
  %% is very similar to \texthaskell{Maybe} in that it represents
  %% possible failure, but it can carry some additional information about
  %% the failure \parencite{yorgey-2009}. The behavior of
  %% \texthaskell{fmap} is practically the same as the behavior of
  %% \texthaskell{fmap} for \texthaskell{Maybe}: a given function is
  %% mapped in the case of a \texthaskell{Right}, but not in the case of
  %% a \texthaskell{Left}. The \texthaskell{Left} is like an empty box or
  %% container (like \texthaskell{Nothing}) with an error message written
  %% on the side which explains why it is empty
  %% \parencite{lipovaca-2011}.

  \begin{proof}

    We begin with the proof of \eqref{eq:functor-identity}. In the
    case of a \texthaskell{Left x}:
    \begin{steps}
      \steph{fmap id (Left x)}
        \eqbydefh{fmap}
      \steph{Left x}
        \eqbydefh{id}
      \steph{id (Left x)}
    \end{steps}
    And in the case of a \texthaskell{Right y}:
    \begin{steps}
      \steph{fmap id (Right y)}
        \eqbydefh{fmap}
      \steph{Right (id y)}
        \eqbydefh{id}
      \steph{Right y}
        \eqbydefh{id}
      \steph{id (Right y)}
    \end{steps}
    We end with the proof of \eqref{eq:functor-composition}. In the
    case of a \texthaskell{Left x}:
    \begin{steps}
      \steph{(fmap h . fmap g) (Left x)}
        \eqbydefh{(.)}
      \steph{fmap h (fmap g (Left x))}
        \eqbydefh{fmap}
      \steph{fmap h (Left x)}
        \eqbydefh{fmap}
      \steph{Left x}
        \eqbydefh{fmap}
      \steph{fmap (h . g) (Left x)}
    \end{steps}
    And in the case of a \texthaskell{Right y}:
    \begin{steps}
      \steph{(fmap h . fmap g) (Right y)}
        \eqbydefh{(.)}
      \steph{fmap h (fmap g (Right y))}
        \eqbydefh{fmap}
      \steph{fmap h (Right (g y))}
        \eqbydefh{fmap}
      \steph{Right (h (g y))}
        \eqbydefh{(.)}
      \steph{Right ((h . g) y)}
        \eqbydefh{fmap}
      \steph{fmap (h . g) (Right y)}
    \end{steps}

  \end{proof}

\end{example}

\begin{example}
  \label{ex:functor-function-haskell}

  %% \parencites[220--222]{lipovaca-2011}[21]{yorgey-2009}

  An interesting example of functors in Haskell is the function
  functor. Its type constructor is \texthaskell{(->) a}, and its
  \texthaskell{fmap} function is function composition:
  \begin{codehaskell}
instance Functor ((->) a) where
  fmap g f = \x -> g (f x)
  \end{codehaskell}
  Or, equivalently:
  \begin{codehaskell}
instance Functor ((->) a) where
  fmap = (.)
  \end{codehaskell}

  %% From \parencite[21]{yorgey-2009}: \texthaskell{((->) e)}, the type
  %% of functions which take a value of type \texthaskell{e} as a
  %% parameter, is a functor. It would be clearer to write it as e ->, by
  %% analogy with an operator section like (1+), but that syntax is not
  %% allowed. However, you can certainly think of it as (e ->). As a
  %% container, (e -> a) represents a (possibly infinite) set of values
  %% of a, indexed by values of e. Alternatively, and more usefully, (e
  %% ->) can be thought of as a context in which a value of type e is
  %% available to be consulted in a read-only fashion. This is also why
  %% ((->) e) is sometimes referred to as the reader monad.

  \begin{proof}

    In the first place, we prove \eqref{eq:functor-identity}:
    \begin{steps}
      \steph{fmap id f}
        \eqbydefh{fmap}
      \steph{id . f}
        \eqby{\eqref{eq:category-identity}}
      \steph{f}
        \eqbydefh{id}
      \steph{id f}
    \end{steps}
    And, in the second place, we prove \eqref{eq:functor-composition}:
    \begin{steps}
      \steph{(fmap h . fmap g) f}
        \eqbydefh{(.)}
      \steph{fmap h (fmap g f)}
        \eqbydefh{fmap}
      \steph{fmap h (g . f)}
        \eqbydefh{fmap}
      \steph{h . (g . f)}
        \eqby{\eqref{eq:category-associativity}}
      \steph{(h . g) . f}
        \eqbydefh{fmap}
      \steph{fmap (h . g) f}
    \end{steps}

  \end{proof}

\end{example}

\begin{example}
  \label{ex:functor-bad-maybe-haskell}

  Since the functor laws are not part of the definition of the
  \texthaskell{Functor} type class, we can redefine the
  \texthaskell{Maybe} functor (see Example
  \ref{ex:functor-maybe-haskell}) as follows:
  \begin{codehaskell}
instance Functor Maybe where
  fmap _ Nothing  = Nothing
  fmap _ (Just _) = Nothing
  \end{codehaskell}
  Even though this definition of the \texthaskell{fmap} function is
  accepted by Haskell, the following counterexample proves that it
  violates the first functor law:
  \begin{codehaskell}
> fmap id (Just 0)
Nothing
> id (Just 0)
Just 0
  \end{codehaskell}
  Note that this is the only alternative declaration of the
  \texthaskell{Maybe} functor.

\end{example}

\begin{example}
  \label{ex:functor-bad-list-haskell}

  We can also redefine the list functor (see Example
  \ref{ex:functor-list-haskell}). Here is the declaration we discussed
  in Section \ref{sec:functors-introduction}:
  \begin{codehaskell}
instance Functor [] where
  fmap _ []     = []
  fmap f (x:xs) = f x : f x : fmap f xs
  \end{codehaskell}
  But this is not the only way to redefine this functor. For instance:
  \begin{codehaskell}
instance Functor [] where
  fmap _ []     = []
  fmap f (x:xs) = [f x]
  \end{codehaskell}
  However, neither of these instances satisfy the first functor law,
  as demonstrated by the following counterexamples. In the first case:
  \begin{codehaskell}
> fmap id [0,1]
[0,0,1,1]
> id [0,1]
[0,1]
  \end{codehaskell}
  And, in the second case:
  \begin{codehaskell}
> fmap id [0,1]
[0]
> id [0,1]
[0,1]
  \end{codehaskell}

\end{example}

\section{Functors in Agda}
\label{sec:functors-agda}

The Agda standard library defines functors in Agda just like functors
in Haskell, that is, without the functor laws\footnote{See
  \parencite[module \module{Category.Functor}]{danielsson-2013}.}.
Abel defines functors in the module \module{Abel.Category.Functor},
which includes the functor laws\footnote{We refer to propositional
  (intensional) equality, as defined in \parencite[module
    \module{Relation.Binary.PropositionalEquality}]{danielsson-2013}.}:
\begin{codeagda}
record Functor (F : Set → Set) : Set₁ where

  constructor mkFunctor

  field

    fmap    : {A B : Set} → (A → B) → F A → F B

    fmap-id : {A : Set} (fx : F A) → fmap id fx ≡ id fx

    fmap-∘  : {A B C : Set} {f : A → B} {g : B → C}
              (fx : F A) → fmap (g ∘ f) fx ≡ (fmap g ∘ fmap f) fx
\end{codeagda}
The inclusion of the functor laws makes it impossible to define a
functor which is not really a functor because all instances must prove
that \textagda{F} and \textagda{fmap} satisfy the laws.

\begin{example}[See module \module{Abel.Data.Maybe.Functor}]
  \label{ex:functor-maybe-agda}

  The \textagda{Maybe} functor in Agda is defined as follows:
  \begin{codeagda}
functor : Functor Maybe
functor = mkFunctor fmap fmap-id fmap-∘
  where
    fmap : {A B : Set} → (A → B) → Maybe A → Maybe B
    fmap f (just x) = just (f x)
    fmap _ nothing  = nothing

    fmap-id : {A : Set} (mx : Maybe A) → fmap id mx ≡ id mx
    fmap-id (just _) = refl
    fmap-id nothing  = refl

    fmap-∘ : {A B C : Set} {f : A → B} {g : B → C}
             (mx : Maybe A) → fmap (g ∘ f) mx ≡ (fmap g ∘ fmap f) mx
    fmap-∘ (just _) = refl
    fmap-∘ nothing  = refl
  \end{codeagda}
  Clearly, this functor corresponds to the \texthaskell{Maybe} functor
  in Haskell (see Example \ref{ex:functor-maybe-haskell}).

\end{example}

\begin{example}[See module \module{Abel.Data.List.Functor}]
  \label{ex:functor-list-agda}

  The following instance corresponds to the list functor in Agda:
  \begin{codeagda}
functor : Functor List
functor = mkFunctor fmap fmap-id fmap-∘
  where
    fmap : {A B : Set} → (A → B) → List A → List B
    fmap _ []       = []
    fmap f (x ∷ xs) = f x ∷ fmap f xs

    fmap-id : {A : Set} (xs : List A) → fmap id xs ≡ id xs
    fmap-id []       = refl
    fmap-id (x ∷ xs) = cong (_∷_ x) (fmap-id xs)

    fmap-∘ : {A B C : Set} {f : A → B} {g : B → C}
             (xs : List A) → fmap (g ∘ f) xs ≡ (fmap g ∘ fmap f) xs
    fmap-∘             []       = refl
    fmap-∘ {f = f} {g} (x ∷ xs) = cong (_∷_ (g (f x))) (fmap-∘ xs)
  \end{codeagda}
  This definition matches that of the list functor in Haskell (see
  Example \ref{ex:functor-list-haskell}).

\end{example}

\begin{example}[See module \module{Abel.Data.Product.Functor}]
  \label{ex:functor-product-agda}

  Here is the declaration of the product functor in Agda (see Example
  \ref{ex:product-agda}):
  \begin{codeagda}
functor : {A : Set} → Functor (_×_ A)
functor {A} = mkFunctor fmap fmap-id fmap-∘
  where
    fmap : {B C : Set} → (B → C) → A × B → A × C
    fmap g (x , y) = x , g y

    fmap-id : {B : Set} (x,y : A × B) → fmap id x,y ≡ id x,y
    fmap-id (x , y) = refl

    fmap-∘ : {B C D : Set} {g : B → C} {h : C → D}
             (x,y : A × B) → fmap (h ∘ g) x,y ≡ (fmap h ∘ fmap g) x,y
    fmap-∘ (x , y) = refl
  \end{codeagda}
  Compare this with the product functor in Haskell (see Example
  \ref{ex:functor-product-haskell}).

\end{example}

\begin{example}[See module \module{Abel.Data.Sum.Functor}]
  \label{ex:functor-coproduct-agda}

  The coproduct functor in Agda (see Example \ref{ex:coproduct-agda})
  is defined as follows:
  \begin{codeagda}
functor : {A : Set} → Functor (_+_ A)
functor {A} = mkFunctor fmap fmap-id fmap-∘
  where
    fmap : {B C : Set} → (B → C) → A + B → A + C
    fmap _ (inj₁ x) = inj₁ x
    fmap g (inj₂ y) = inj₂ (g y)

    fmap-id : {B : Set} (x+y : A + B) → fmap id x+y ≡ id x+y
    fmap-id (inj₁ _) = refl
    fmap-id (inj₂ _) = refl

    fmap-∘ : {B C D : Set} {g : B → C} {h : C → D}
             (x+y : A + B) → fmap (h ∘ g) x+y ≡ (fmap h ∘ fmap g) x+y
    fmap-∘ (inj₁ _) = refl
    fmap-∘ (inj₂ _) = refl
  \end{codeagda}
  Compare this with the coproduct functor in Haskell (see Example
  \ref{ex:functor-coproduct-haskell}).

\end{example}

\begin{example}[See module \module{Abel.Function.Functor}]
  \label{ex:functor-function-agda}

  Here is the definition of the function functor in Agda, which
  corresponds to the Haskell functor described in Example
  \ref{ex:functor-function-haskell}:
  \begin{codeagda}
functor : {A : Set} → Functor (λ B → A → B)
functor = mkFunctor (λ g f → g ∘ f) (λ _ → refl) (λ _ → refl)
  \end{codeagda}

\end{example}

\begin{example}
  \label{ex:functor-bad-maybe-agda}

  We can try to define the alternative \texthaskell{Maybe} functor of
  Example \ref{ex:functor-bad-maybe-haskell} in Agda:
  \begin{codeagda}
functor : Functor Maybe
functor = mkFunctor fmap fmap-id fmap-∘
  where
    fmap : {A B : Set} → (A → B) → Maybe A → Maybe B
    fmap f (just x) = nothing
    fmap _ nothing  = nothing

    fmap-id : {A : Set} (mx : Maybe A) → fmap id mx ≡ id mx
    fmap-id (just _) = ?
    fmap-id nothing  = refl

    fmap-∘ : {A B C : Set} {f : A → B} {g : B → C}
             (mx : Maybe A) → fmap (g ∘ f) mx ≡ (fmap g ∘ fmap f) mx
    fmap-∘ (just _) = refl
    fmap-∘ nothing  = refl
  \end{codeagda}
  But this code does not type check because there is a proof missing.
  As we saw in Example \ref{ex:functor-bad-maybe-haskell}, the first
  functor law does not hold for this definition of the
  \textagda{Maybe} functor, so there is no way to make this instance
  type check in Agda.

\end{example}

\section{References}
\label{sec:functors-references}

The definition of a functor is based on
\parencites[13]{maclane-1998}[428]{poigne-1992}, the power set and
identity functors are taken from \parencites[431]{poigne-1992} and
\parencite[11]{marquis-2013}, respectively, and the study of functors
in Haskell is based on \parencites[146--150,
  218--227]{lipovaca-2011}[18--23]{yorgey-2009}.

\clearemptydoublepage
