\chapter{Conclusions}
\label{chap:conclusions}

\begin{epigraphs}
\qitem{
  ``What dreadful nonsense we \emph{are} talking!''
}{---\textcite[255]{carroll-2004}}
\qitem{
  ``You may call it `nonsense' if you like, but \emph{I've} heard
  nonsense, compared with which that would be as sensible as a
  dictionary!''
}{---\textcite[173]{carroll-2004}}
\end{epigraphs}

Our main objective with this project was to study some of the
applications of category theory to functional programming in Haskell
and Agda, and, more specifically, to describe and explain the concepts
of category theory needed for conceptualizing and better understanding
functors, polymorphism, monads, and algebraic data types, which we did
in Chapters \ref{chap:functors}, \ref{chap:naturals},
\ref{chap:monads}, and \ref{chap:algebras}, respectively. In Chapter
\ref{chap:categories}, we identified categories as the starting point
for relating category theory to functional programming. In the case of
algebraic data types and, more usefully, folds, we identified algebras
and initial algebras over endofunctors as the required concepts for
satisfying our main goal; in the case of functors, the notions of
functor and endofunctor; in the case of monads, the concepts of monad
and Kleisli triple; and, in the case of polymorphism or, more
precisely, parametric polymorphism, natural transformations.

Obviously, we did not cover all of category theory. For instance, we
did not deal with concepts such as adjoints, epimorphisms, limits,
monomorphisms, and universal constructions, which were listed in the
project proposal, but did not answer our purpose. Having said that, we
did cover the trinity of concepts category, functor, and natural
transformation, which is the foundation of all category theory, and
which creates an opportunity for a deeper understanding of the
subject.

Additionally, some of the applications of category theory to
functional programming are not as straightforward as suggested here.
For example, polymorphic functions actually correspond to lax natural
transformations, and algebraic data types in Haskell correspond to
initial algebras and terminal coalgebras over endofunctors, but such
concepts go beyond the scope of this project. However, our use of
category theory seems to be appropriate and useful, especially from
the standpoint of functional programming.

In this regard, we stated that one can be a perfectly competent
functional programmer without knowledge of category theory, and that
categorical concepts can be applied to functional programming with the
intention of, for instance, becoming a better programmer. Although
subjective, we believe that this project provides some interesting
examples of how to take advantage of category theory in functional
programming and programming in general.

Needless to say, the ideas of category theory might be difficult to
understand at first. As a matter of fact,
\textcite[25]{bird-demoor-1997} claim that ``one does not so much
learn category theory as absorb it over a period of time.'' We claim
that it is definitely worth it.

\section{Future Work}

All unanswered questions and concepts beyond the scope of this project
could be considered as suggestions for future work. For instance, the
questions of Haskell's and Agda's categories, the existence of initial
algebras over endofunctors, and others. We describe two ideas which we
find interesting and appropriate.

\paragraph{Agda}

Whenever suitable for our objective, we used category theory in Agda,
but focused on Haskell. Even though helpful, additional projects could
benefit much more from really exploting a programming language such as
Agda.

\paragraph{Applicative functors}

Based on \parencite{mcbride-paterson-2008}, we identified and studied
monoidal functors in order to be able to understand applicative
functors from a category-theoretical point of view, but we did not
include our results here. This seems to be a very relevant next step,
particularly in the context of the ``current, and very likely to
succeed,'' Haskell 2014 \texthaskell{Applicative => Monad}
proposal\footnote{\url{http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal}.},
which adds an \texthaskell{Applicative} constraint to the
\texthaskell{Monad} type class and promotes \texthaskell{join} to
\texthaskell{Monad}, which we briefly discussed in Remark
\ref{re:monad-bind}.

\clearemptydoublepage
